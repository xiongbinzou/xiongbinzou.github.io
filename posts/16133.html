<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>C#语言进阶学习笔记 | 小邹同学</title><meta name="keywords" content="学习笔记,Unity开发基础,C#进阶"><meta name="author" content="小邹同学"><meta name="copyright" content="小邹同学"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C#又称”C Sharp“，是微软发布和维护的一个现代的、通用的、面向对象的编程语言，是专为公共语言基础结构CLI设计的。"><meta property="og:type" content="article"><meta property="og:title" content="C#语言进阶学习笔记"><meta property="og:url" content="https://xiongbinzou.github.io/posts/16133.html"><meta property="og:site_name" content="小邹同学"><meta property="og:description" content="C#又称”C Sharp“，是微软发布和维护的一个现代的、通用的、面向对象的编程语言，是专为公共语言基础结构CLI设计的。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xiongbinzou.github.io/pics/avatar.jpg"><meta property="article:published_time" content="2022-08-16T13:00:00.000Z"><meta property="article:modified_time" content="2022-10-27T16:40:13.476Z"><meta property="article:author" content="小邹同学"><meta property="article:tag" content="学习笔记"><meta property="article:tag" content="Unity开发基础"><meta property="article:tag" content="C#进阶"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiongbinzou.github.io/pics/avatar.jpg"><link rel="shortcut icon" href="/pics/favicon.png"><link rel="canonical" href="https://xiongbinzou.github.io/posts/16133"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:300,languages:{author:"作者: 小邹同学",link:"链接: ",source:"来源: 小邹同学",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C#语言进阶学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-10-28 00:40:13"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 5.4.2"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/pics/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-graduation-cap"></i> <span>博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i> <span>相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>影视</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小邹同学</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-graduation-cap"></i> <span>博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i> <span>相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>影视</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C#语言进阶学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-16T13:00:00.000Z" title="发表于 2022-08-16 21:00:00">2022-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-27T16:40:13.476Z" title="更新于 2022-10-28 00:40:13">2022-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C#</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-特性">1. 特性</h2><p><strong>特性（Attribute）是一种用于在程序运行时传递各种元素（例如类、方法、结构、枚举等）行为信息的声明性代码</strong>。使用特性可以将元数据（例如编译器指令、注释、描述、方法和类等信息）添加到程序中。<strong>.Net Framework</strong> 提供了两种类型的特性，分别是预定义特性和自定义特性。</p><p>在C#中，特性具有以下属性：</p><ul><li>使用特性可以向程序中添加元数据，元数据是指程序中各种元素的相关信息，所有.NET程序中都包含一组指定的元数据；</li><li>可以将一个或多个特性应用于整个程序、模块或者较小的程序元素（例如类或属性）中；</li><li>特性可以像方法和属性一样接收自变量；</li><li>程序可使用反射来检查自己的元数据或其他程序中的元数据</li></ul><p>定义特性的语法如下：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">[attribute(positional_parameters, name_parameter=value, ...)]</span><br><span class="line">element</span><br></pre></td></tr></tbody></table></figure><p>其中，<code>[]</code>中用来定义特性的名称和值，<code>positional_parameters</code>用来指定基本信息，<code>name_parameter</code>用来指定可选信息</p><h3 id="1-1-预定义特性">1.1 预定义特性</h3><p><strong>.Net Framework</strong>中提供了三个预定义的属性：<code>AttributeUsage</code>、<code>Conditional</code>和<code>Obsolete</code>。</p><p><strong>AttributeUsage</strong></p><p>预定义特性<code>AttributeUsage</code>用来描述如何使用自定义特性类，其中定义了可以引用特性的项目类型。其语法如下：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">[AttributeUsage(</span><br><span class="line">    validon,</span><br><span class="line">    AllowMultiple = allowmultiple,</span><br><span class="line">    Inherited = inherited</span><br><span class="line">)]</span><br></pre></td></tr></tbody></table></figure><ul><li>参数<code>validon</code>用来定义特性可被放置的语言元素，它是枚举器<strong>AttributeTargets</strong>的值的集合，默认是<strong>AttributeTargets.All</strong></li><li>参数<code>allowmultiple</code>（可选参数）用来为该特性的<strong>AllowMultiple</strong>属性（property）提供一个布尔值，默认为false，单用的，如果为true表示多用的</li><li>参数<code>inherited</code>（可选参数）用来对该特性的Inherited属性（property）提供一个布尔值，默认为false，不被继承的，如果为true表示可被派生类继承</li></ul><p>示例代码：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class |</span></span><br><span class="line"><span class="meta">                AttributeTargets.Constructor | </span></span><br><span class="line"><span class="meta">                AttributeTargets.Field | </span></span><br><span class="line"><span class="meta">                AttributeTargets.Method |</span></span><br><span class="line"><span class="meta">                AttributeTargets.Property,</span></span><br><span class="line"><span class="meta">                AllowMultiple=true)</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>Conditional</strong></p><p>预定义特性<code>Conditional</code>用来定义条件方法。<code>Conditional</code>属性通过测试条件编译符号来确定适用的条件，当运行到一个条件方法调用时，是否执行该调用，要根据出现该调用时是否已定义了此符号来确定。使用<code>Conditional</code>是封闭<code>#if</code>和<code>#endif</code>内部方法的替代方法，它更整洁、别致、减少出错的机会。其语法如下：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">[Conditional(conditionalSymbol)]</span><br></pre></td></tr></tbody></table></figure><p>示例代码：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ConditionalTest</span></span><br><span class="line">    {</span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">"DEBUG"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func1</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            MyClass.Message(<span class="string">"Func1函数"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">"BUG"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func2</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            MyClass.Message(<span class="string">"Func2函数"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            MyClass.Message(<span class="string">"Main函数"</span>);</span><br><span class="line">            Func1();</span><br><span class="line">            Func2();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Message</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(msg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Main函数</span></span><br><span class="line">    <span class="comment">// Func1函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Obsolete</strong></p><p>预定义特性<code>Obsolete</code>用来标记不应该被使用的程序，可以使用它来通知编译器放弃某个目标元素。例如当你需要使用一个新方法来代替类中的某个旧方法时，就可以使用该特性将旧方法标记为<code>Obsolete</code>（过时）的并输出一条信息，来提示我们应该使用新方法替代旧方法。其语法格式如下：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">[Obsolete(message)]</span><br><span class="line"></span><br><span class="line">[Obsolete(message, iserror)]</span><br></pre></td></tr></tbody></table></figure><ul><li>参数<code>message</code>是一个用来描述项目为什么过时以及用什么替代的字符串</li><li>参数<code>iserror</code>是一个布尔值，默认值为false，如果设置为true，则编译器会把该项目当做一个错误</li></ul><p>示例代码：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ObsoleteTest</span></span><br><span class="line">    {</span><br><span class="line">        [<span class="meta">Obsolete(<span class="meta-string">"OldMethod已弃用，请改用NewMethod"</span>, true)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OldMethod</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">"已弃用的函数"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewMethod</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">"新定义的函数"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            OldMethod();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Main.cs(17,13): error CS0619: `Application.ObsoleteTest.OldMethod()' is obsolete: `OldMethod已弃用，请改用NewMethod'</span></span><br><span class="line">        <span class="comment">// Compilation failed: 1 error(s), 0 warnings</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-自定义特性">1.2 自定义特性</h3><p><strong>.Net Framework</strong>允许创建自定义特性，自定义特性不仅可以用于存储声明性的信息，还可以在运行时被检索。创建并使用自定义特性分为四个步骤：</p><ul><li>声明自定义特性</li><li>构建自定义特性</li><li>在目标程序上应用自定义特性</li><li>通过反射访问自定义特性</li></ul><p>最后一步涉及编写一个简单的程序来读取元数据以便查找各种符号。元数据是有关数据或用于描述其他数据信息的数据，该程序应在运行时使用反射来访问属性。</p><p><strong>声明自定义特性</strong></p><p>自定义特性应该继承System.Attribute类，如下所示：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line">[<span class="meta">AttributeUsage(</span></span><br><span class="line"><span class="meta">    AttributeTargets.All,</span></span><br><span class="line"><span class="meta">    AllowMultiple = true,</span></span><br><span class="line"><span class="meta">    Inherited = true</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomethingAttribute</span> : <span class="title">Attribute</span> {}</span><br></pre></td></tr></tbody></table></figure><p><strong>构建自定义特性</strong></p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomethingAttribute</span> : <span class="title">Attribute</span> </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> data;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> name; }</span><br><span class="line">        <span class="keyword">set</span> { name = <span class="keyword">value</span>; }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Data</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> data; }</span><br><span class="line">        <span class="keyword">set</span> { data = <span class="keyword">value</span>; }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomethingAttribute</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> data</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>应用自定义特性</strong></p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-attr">[SomethingAttribute(<span class="string">"Amy"</span>, data = <span class="string">"Name is Amy"</span>)]</span></span><br><span class="line"><span class="selector-attr">[SomethingAttribute(<span class="string">"Tom"</span>, data = <span class="string">"Name is Tom"</span>)]</span></span><br><span class="line">class Test {}</span><br></pre></td></tr></tbody></table></figure><p><strong>访问自定义特性</strong></p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line"><span class="keyword">var</span> something = t.GetCustomAttributes(<span class="keyword">typeof</span>(SomethingAttribute), <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">foreach</span>(SomethingAttribute each <span class="keyword">in</span> something)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">"Name: {0}"</span>, each.Name);</span><br><span class="line">    Console.WriteLine(<span class="string">"Data: {0}"</span>, each.Data);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-反射">2. 反射</h2><p>**反射（Reflection）是指程序可以访问、检查、修改它本身行为或状态的一种能力。**反射中提供了用来描述程序集、模块和类型的对象，可以使用反射动态地创建类型的实例，并将类型绑定到现有对象，或者从现有对象中获取类型，然后调用其方法或访问其字段和属性。如果代码中使用了特性，也可以利用反射来访问。</p><h3 id="2-1-反射优缺点">2.1 反射优缺点</h3><p>优点：</p><ul><li>反射提高了程序的灵活性和扩展性</li><li>降低耦合性，提高自适应能力</li><li>运行程序创建和控制任何类的对象，无需提前硬编码目标类</li></ul><p>缺点：</p><ul><li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求高的系统框架上，普通程序不建议使用</li><li>使用反射会模糊程序内部逻辑，程序希望在源代码中看到程序逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂</li></ul><h3 id="2-2-反射用途">2.2 反射用途</h3><ul><li>允许在运行时查看特性信息</li><li>允许审查集合中的各种类型，以及实例化这些类型</li><li>允许延迟绑定的方法和属性</li><li>允许在运行时创建新类型，然后使用这些类型执行一些任务</li></ul><h3 id="2-3-查看元数据">2.3 查看元数据</h3><p>使用反射可以查看特性信息，<strong>System.Reflection</strong>类的 <strong>MemberInfo</strong> 对象需要被初始化，用于发现与类相关的特性，为此可以定义目标类的一个对象：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.All)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelpAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">string</span> Url;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Topic</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> topic;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        {</span><br><span class="line">            topic = <span class="keyword">value</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelpAttribute</span>(<span class="params"><span class="built_in">string</span> url</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.Url = url;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> topic;</span><br><span class="line">}</span><br><span class="line">[<span class="meta">HelpAttribute(<span class="meta-string">"Infomation to the class MyClass"</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            System.Reflection.MemberInfo info = <span class="keyword">typeof</span>(MyClass);</span><br><span class="line">            <span class="built_in">object</span>[] attributes = info.GetCustomAttributes(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">for</span>	(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; attributes.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                System.Console.WriteLine(attributes[i]);  <span class="comment">// HelpAttribute</span></span><br><span class="line">            }</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="3-属性">3. 属性</h2><p><strong>属性（Property）是类、结构和接口的命名成员</strong>。类或结构中的成员变量或方法称为域，属性是域的扩展，且可以使用相同的语法来访问，他们使用访问器让私有域的值可被读写或操作。</p><p>属性不会确定存储位置，他们具有可读写或计算他们值的访问器。</p><p>例如，一个名为Student的类，带有age、name或code的私有域，我们不能在类的范围外直接访问这些域，但是可以拥有访问这些私有域的属性。</p><h3 id="3-1-get-set访问器">3.1 get/set访问器</h3><p>属性的访问器包括获取或写入属性的可执行语句，访问器可包含一个<strong>get访问器</strong>或一个<strong>set访问器</strong>，或者两种都包含。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name = <span class="string">"NAN"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">get</span> </span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            {</span><br><span class="line">                name = <span class="keyword">value</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 简写形式</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Name = "</span> + Name + <span class="string">", Age = "</span> + Age;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PropertiesTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">            t.Name = <span class="string">"Zhang"</span>;</span><br><span class="line">            t.Age = <span class="number">26</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"Teacher Info: {0}"</span>, t);</span><br><span class="line">            t.Age += <span class="number">1</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"Teacher Info: {0}"</span>, t);</span><br><span class="line">            <span class="comment">// Teacher Info: Name = Zhang, Age = 26</span></span><br><span class="line">            <span class="comment">// Teacher Info: Name = Zhang, Age = 27</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-抽象属性">3.2 抽象属性</h3><p>在抽象类中可以拥有抽象属性，这些属性会在派生类中实现。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">int</span> Age { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Teacher</span> : <span class="title">Person</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Project { <span class="keyword">get</span>; <span class="keyword">set</span>; } = <span class="string">"NAN"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; } = <span class="string">"NAN"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> Age { <span class="keyword">get</span>; <span class="keyword">set</span>; } = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$"Project = <span class="subst">{Project}</span>, Name = <span class="subst">{Name}</span>, Age = <span class="subst">{Age}</span>"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title">AbstractPropertiesTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> Teacher()</span><br><span class="line">            {</span><br><span class="line">                Project = <span class="string">"Math"</span>,</span><br><span class="line">                Name = <span class="string">"Zhang"</span>,</span><br><span class="line">                Age = <span class="number">26</span></span><br><span class="line">            };</span><br><span class="line">            Console.WriteLine(<span class="string">$"Teacher Info: <span class="subst">{t}</span>"</span>);</span><br><span class="line">            t.Age++;</span><br><span class="line">            Console.WriteLine(<span class="string">$"Teacher Info: <span class="subst">{t}</span>"</span>);</span><br><span class="line">			<span class="comment">// Teacher Info: Project = Math, Name = Zhang, Age = 26</span></span><br><span class="line">			<span class="comment">// Teacher Info: Project = Math, Name = Zhang, Age = 27</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-索引器">4. 索引器</h2><p><strong>索引器（Indexer）是类中的一个特殊成员，他能够让对象以类似数组的形式来操作</strong>，使程序看起来更直观、更易编写。索引器与属性类似，在定义索引器时同样会get和set访问器，不同的是，访问索引器需要提供相应的参数。</p><h3 id="4-1-索引器定义">4.1 索引器定义</h3><p>索引器允许对象使用下标的方式来访问，定义时，该类的行为会像一个虚拟数组一样，可以使用数组访问符<code>[ ]</code>来访问类的成员。</p><p>其语法为：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">element-type this[int index]</span><br><span class="line">{</span><br><span class="line">    // get访问器</span><br><span class="line">    get</span><br><span class="line">    {</span><br><span class="line">        // 返回index指定的值</span><br><span class="line">    }</span><br><span class="line">    // set访问器</span><br><span class="line">    set</span><br><span class="line">    {</span><br><span class="line">        // 设置index指定的值</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-2-索引器用途">4.2 索引器用途</h3><p>索引器实例数据分为更小的部分，并索引每部分，获取或设置每部分。索引器定义时不带名称，但带this关键字，它指向对象实例。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">IndexedNames</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>[] nameList = <span class="keyword">new</span> <span class="built_in">string</span>[size];</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> size = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexedNames</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>	(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            {</span><br><span class="line">                nameList[i] = <span class="string">"NAN"</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">string</span> tmp;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size - <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    tmp = nameList[index];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    tmp = <span class="string">""</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> ( tmp );</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size - <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    nameList[index] = <span class="keyword">value</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            IndexedNames names = <span class="keyword">new</span> IndexedNames();</span><br><span class="line">            names[<span class="number">0</span>] = <span class="string">"AAA"</span>;</span><br><span class="line">            names[<span class="number">1</span>] = <span class="string">"BBB"</span>;</span><br><span class="line">            names[<span class="number">2</span>] = <span class="string">"CCC"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; IndexedNames.size; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(names[i]);</span><br><span class="line">            }</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// AAA</span></span><br><span class="line">        <span class="comment">// BBB</span></span><br><span class="line">        <span class="comment">// CCC</span></span><br><span class="line">        <span class="comment">// NAN</span></span><br><span class="line">        <span class="comment">// NAN</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-重载索引器">4.3 重载索引器</h3><p>索引器可以被重载，而且在声明索引器时也可以带多个参数，每个参数可以是不同的类型，另外，索引器的索引不必是整数，也可以是其他类型，例如字符串类型。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">IndexedNames</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>[] nameList = <span class="keyword">new</span> <span class="built_in">string</span>[size];</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> size = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexedNames</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>	(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            {</span><br><span class="line">                nameList[i] = <span class="string">"NAN"</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">string</span> tmp;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size - <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    tmp = nameList[index];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    tmp = <span class="string">""</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> ( tmp );</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size - <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    nameList[index] = <span class="keyword">value</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">string</span> name]</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; size)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (nameList[index] == name)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">return</span> index;</span><br><span class="line">                    }</span><br><span class="line">                    index++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> IndexedNames();</span><br><span class="line">            names[<span class="number">0</span>] = <span class="string">"AAA"</span>;</span><br><span class="line">            names[<span class="number">1</span>] = <span class="string">"BBB"</span>;</span><br><span class="line">            names[<span class="number">2</span>] = <span class="string">"CCC"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; IndexedNames.size; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(names[i]);</span><br><span class="line">            }</span><br><span class="line">            Console.WriteLine(<span class="string">"'BBB'的索引为: {0}"</span>, names[<span class="string">"BBB"</span>]);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// AAA</span></span><br><span class="line">        <span class="comment">// BBB</span></span><br><span class="line">        <span class="comment">// CCC</span></span><br><span class="line">        <span class="comment">// NAN</span></span><br><span class="line">        <span class="comment">// NAN</span></span><br><span class="line">        <span class="comment">// 'BBB'的索引为: 1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-委托">5. 委托</h2><p>**委托（Delegate）类似于C或C++中函数的指针，是存有对某个方法的引用的一种引用类型的变量。**引用可在运行时被改变。</p><p>委托特别用于实现事件和回调方法，所有的委托都派生自<strong>System.Delegate</strong>类。</p><h3 id="5-1-声明委托">5.1 声明委托</h3><p>委托声明决定了可由委托引用的方法。委托可指向一个与其具有相同标签的方法。</p><p>声明委托的语法如下：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">delegate <span class="tag">&lt;<span class="name">return</span> <span class="attr">type</span>&gt;</span> <span class="tag">&lt;<span class="name">delegate-name</span>&gt;</span> <span class="tag">&lt;<span class="name">parameter</span> <span class="attr">list</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-实例化委托">5.2 实例化委托</h3><p>声明委托类型后，委托对象必须由<code>new</code>关键字来创建，且与一个特定的方法关联。当创建委托时，传递到new语句的参数就像方法调用一样书写，但是不带参数。</p><p>示例如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="comment">// 声明委托</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">DelegateTest1</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">        {</span><br><span class="line">            num += p;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MulNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line">        {</span><br><span class="line">            num *= q;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 实例化委托</span></span><br><span class="line">            NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MulNum);</span><br><span class="line">            <span class="comment">// 使用委托对象调用方法</span></span><br><span class="line">            nc1(<span class="number">25</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"Value of Num: {0}"</span>, getNum());  <span class="comment">// Value of Num: 35</span></span><br><span class="line">            nc2(<span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"Value of Num: {0}"</span>, getNum());  <span class="comment">// Value of Num: 175</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-委托多播">5.3 委托多播</h3><p>委托对象可以使用<code>+</code>运算符进行合并。一个合并委托调用它所合并的两个委托，只有同类型的委托才能被合并。<code>-</code>运算符可用于从合并的委托中移除组件委托。</p><p>使用委托合并或移除的操作，可以创建一个委托被调用时要调用的方法的调用类别，这称为委托的多播。</p><p>示例如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="comment">// 声明委托</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">DelegateTest2</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">        {</span><br><span class="line">            num += p;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MulNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line">        {</span><br><span class="line">            num *= q;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 实例化委托</span></span><br><span class="line">            NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MulNum);</span><br><span class="line">            NumberChanger nc = nc1 + nc2;</span><br><span class="line">            <span class="comment">// 调用多播</span></span><br><span class="line">            nc(<span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"Value of Num: {0}"</span>, getNum());  <span class="comment">// Value of Num: 75</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-事件">6. 事件</h2><p><strong>事件（Event）基本上说是一个用户操作</strong>，例如按键、点击、鼠标移动等，或者<strong>是一些提示信息</strong>，如系统生成的通知。<strong>应用程序需要在事件发生时响应事件</strong>。C#中使用事件机制实现线程间的通信。</p><h3 id="6-1-声明事件">6.1 声明事件</h3><p>在类的内部声明事件，首先必须声明该事件的委托类型，如：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">LogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p>然后，声明事件本身，使用<code>event</code>关键字：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> LogHandler EventLog;</span><br></pre></td></tr></tbody></table></figure><p>上面代码定义了一个名为<strong>EventLog</strong>的事件和一个名为<strong>LogHandler</strong>的委托，该事件在生成时会调用委托。</p><h3 id="6-2-使用事件">6.2 使用事件</h3><p>示例1：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEvent</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 定义一个委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">// 定义一个事件</span></span><br><span class="line">        <span class="keyword">public</span> MyDelegate MyDelegateEvent;</span><br><span class="line">        <span class="comment">// 定义一个事件的触发函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnMyDelegateEvent</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (MyDelegateEvent != <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 执行事件</span></span><br><span class="line">                MyDelegateEvent();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title">EventTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PutOutChar</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">"I was fired"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PutOutChar2</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            COnsole.WriteLine(<span class="string">"I was fired too"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 实例化MyEvent类</span></span><br><span class="line">            MyEvent myEvent = <span class="keyword">new</span> MyEvent();</span><br><span class="line">            <span class="comment">// 注册一个事件</span></span><br><span class="line">            myEvent.MyDelegateEvent += <span class="keyword">new</span> MyEvent.MyDelegate(PutOutChar);</span><br><span class="line">            myEvent.MyDelegateEvent += <span class="keyword">new</span> MyEvent.MyDelegate(PutOutChar2); </span><br><span class="line">            <span class="comment">// 执行触发事件的函数</span></span><br><span class="line">            myEvent.OnMyDelegateEvent();</span><br><span class="line">            <span class="comment">// 解绑一个事件</span></span><br><span class="line">            myEvent.MyDelegateEvent -= <span class="keyword">new</span> MyEvent.MyDelegate(putOutChar);</span><br><span class="line">            <span class="comment">// 再次执行触发事件的函数</span></span><br><span class="line">            myEvent.OnMyDelegateEvent();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// I was fired</span></span><br><span class="line">		<span class="comment">// I was fired too</span></span><br><span class="line">		<span class="comment">// I was fired too</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例2：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 发布器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> <span class="keyword">value</span>;</span><br><span class="line">        <span class="comment">// 定义一个委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;</span><br><span class="line">        <span class="comment">// 定义一个事件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> MyDelegate MyEvent;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">value</span> = s;</span><br><span class="line">            <span class="comment">// 触发事件</span></span><br><span class="line">            MyEvent(<span class="keyword">value</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintF</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            Publisher p = <span class="keyword">new</span> Publisher();</span><br><span class="line">            Subscriber s = <span class="keyword">new</span> Subscriber();</span><br><span class="line">            p.MyEvent += <span class="keyword">new</span> Publisher.MyDelegate(s.PrintF);</span><br><span class="line">            p.SetValue(<span class="string">"Hello"</span>);  <span class="comment">// Hello</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="7-集合">7. 集合</h2><p><strong>集合（Collection）类是专门用于数据存储和检索的类，这些类提供了对栈（Stack）、队列（Queue）、列表（List）和哈希表（Hashtable）的支持。大多数集合类实现了相同的接口。</strong></p><p>集合类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等，这些类创建Object类的对象的集合，<strong>在C#在，Object类是所有数据类型的基类</strong>。</p><h3 id="7-1-动态数组ArrayList">7.1 动态数组ArrayList</h3><p><strong>动态数组ArrayList代表了可被单独索引的对象的有序集合</strong>，它基本上可以替代一个数组。与数组不同的是，可以使用索引在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。</p><p>下表为ArrayList类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>Capacity</code></td><td>获取或设置ArrayList可包含的元素个数</td><td><code>Count</code></td><td>获取ArrayList中实际包含的元素个数</td></tr><tr><td><code>IsFixedSize</code></td><td>获取一个值，表示ArrayList是否具有固定大小</td><td><code>IsReadOnly</code></td><td>获取一个值，表示ArrayList是否只读</td></tr><tr><td><code>IsSynchronized</code></td><td>获取一个值，表示访问ArrayList是否同步（线程安全）</td><td><code>Item[Int32]</code></td><td>获取或设置指定索引处的元素</td></tr><tr><td><code>SyncRoot</code></td><td>获取一个对象用于同步访问ArrayList</td><td></td><td></td></tr></tbody></table><p>下表为ArrayList类的常用方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>public virtual int Add(object value);</code></td><td>在ArrayList的列表末尾添加一个对象</td><td><code>public virtual void AddRange(ICollection c);</code></td><td>在ArrayList的列表末尾添加ICollection的元素</td></tr><tr><td><code>public virtual void Clear();</code></td><td>在ArrayList中移除所有元素</td><td><code>public virtual bool Contains(object item);</code></td><td>判断某个元素是否存在ArrayList中</td></tr><tr><td><code>public virtual ArrayList GetRange(int index, int count);</code></td><td>返回一个ArrayList，表示源ArrayList中元素的子集</td><td><code>public virtual int IndexOf(object);</code></td><td>返回某个值在ArrayLust中第一次出现的索引，索引从零开始</td></tr><tr><td><code>public virtual void Insert(int index, object value);</code></td><td>在ArrayList指定索引处插入一个元素</td><td><code>public virtual void InsertRange(int index, ICollection c);</code></td><td>在ArrayList的指定索引处，插入某个集合的元素</td></tr><tr><td><code>public virtual void Remove(object obj);</code></td><td>从ArrayList中移除第一次出现的指定对象</td><td><code>public virtual void RemoveAt(int index);</code></td><td>移除ArrayList的指定索引处的元素</td></tr><tr><td><code>public virtual void RemoveRange(int index, int count);</code></td><td>在ArrayList中移除某个范围的元素</td><td><code>public virtual void Reverse();</code></td><td>逆转ArrayList在元素的顺序</td></tr><tr><td><code>public virtual void SetRange(int index, ICollection c);</code></td><td>复制某个集合的元素到ArrayList中某个范围的元素上</td><td><code>public virtual void Sort();</code></td><td>对ArrayList中的元素进行排序</td></tr><tr><td><code>public virtual void TrimToSize();</code></td><td>设置容量为ArrayList中元素的实际个数</td><td></td><td></td></tr></tbody></table><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ArrayListTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            ArrayList arrList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            arrList.Add(<span class="number">42</span>);</span><br><span class="line">            arrList.Add(<span class="number">35</span>);</span><br><span class="line">            arrList.Add(<span class="number">55</span>);</span><br><span class="line">            arrList.Add(<span class="number">29</span>);</span><br><span class="line">            arrList.Add(<span class="number">7</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"Capacity: {0}"</span>, arrList.Capacity);  <span class="comment">// Capacity: 8</span></span><br><span class="line">            Console.WriteLine(<span class="string">"Count: {0}"</span>, arrList.Count); <span class="comment">// Count: 5</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> e <span class="keyword">in</span> arrList)</span><br><span class="line">            {</span><br><span class="line">                Console.Write(e + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 42 35 55 29 7</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.Write(<span class="string">"Sorted: "</span>);</span><br><span class="line">            arrList.Sort();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> e <span class="keyword">in</span> arrList)</span><br><span class="line">            {</span><br><span class="line">                Console.Write(e + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Sorted: 7 29 35 42 55</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            arrList.Reverse();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> e <span class="keyword">in</span> arrList)</span><br><span class="line">            {</span><br><span class="line">                Console.Write(e + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Sorted: 55 42 35 29 7</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-2-哈希表Hashtable">7.2 哈希表Hashtable</h3><p><strong>哈希表Hashtable类代表了一系列基于键的哈希代码组织起来的键/值对</strong>。它是由键来访问集合中的元素。哈希表中的每一项都有一个键/值对，键用于访问集合中的项目。</p><p>下表为Hashtable类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>Keys</code></td><td>获取一个ICollection，包含Hashtable中的键</td><td><code>Values</code></td><td>获取一个ICollection，包含Hashtable中的值</td></tr><tr><td><code>IsFixedSize</code></td><td>获取一个值，表示Hashtable是否具有固定大小</td><td><code>IsReadOnly</code></td><td>获取一个值，表示Hashtable是否只读</td></tr><tr><td><code>Count</code></td><td>获取Hashtable中实际包含的键值对个数</td><td><code>Item</code></td><td>获取或设置指定键相关的值</td></tr></tbody></table><p>下表为Hashtable类的常用方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>public virtual void Add(object key, object value)</code></td><td>向Hashtable添加一个带有指定键和值的元素</td><td><code>public virtual void Clear()</code></td><td>从Hashtable中移除所有的元素</td></tr><tr><td><code>public virtual bool ContainsKey(object key)</code></td><td>判断Hashtable是否包含指定的键</td><td><code>public virtual bool ContainsValue(object value)</code></td><td>判断Hashtable是否包含指定的值</td></tr><tr><td><code>public virtual void Remove(object key);</code></td><td>从Hashtable移除带有指定的键的元素</td><td></td><td></td></tr></tbody></table><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HashtableTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            Hashtable hashT = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            hashT.Add(<span class="string">"001"</span>, <span class="string">"AAA"</span>);</span><br><span class="line">            hashT.Add(<span class="string">"002"</span>, <span class="string">"BBB"</span>);</span><br><span class="line">            hashT.Add(<span class="string">"003"</span>, <span class="string">"CCC"</span>);</span><br><span class="line">            hashT.Add(<span class="string">"004"</span>, <span class="string">"DDD"</span>);</span><br><span class="line">            hashT.Add(<span class="string">"005"</span>, <span class="string">"EEE"</span>);</span><br><span class="line">            <span class="keyword">if</span> (hashT.ContainsValue(<span class="string">"FFF"</span>))</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"The 'BBB' is already in the table"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                hashT.Add(<span class="string">"006"</span>, <span class="string">"FFF"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 获取键的集合</span></span><br><span class="line">            ICollection keys = hashT.Keys;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">string</span> k <span class="keyword">in</span> keys)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(k + <span class="string">": "</span> + hashT[k]);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 002: BBB</span></span><br><span class="line">			<span class="comment">// 001: AAA</span></span><br><span class="line">			<span class="comment">// 003: CCC</span></span><br><span class="line">			<span class="comment">// 004: DDD</span></span><br><span class="line">			<span class="comment">// 006: FFF</span></span><br><span class="line">			<span class="comment">// 005: EEE</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-3-排序列表SortedList">7.3 排序列表SortedList</h3><p><strong>排序列表SortedList类代表了一系列按照键来排序的键/值对，这些键值对可以通过键或索引来访问。</strong></p><p>排序列表是数组和哈希表的组合，包含了一个可使用键或索引访问各项的列表。如果使用索引访问各项，则它是一个动态数组，如果使用键访问各项，则它是一个哈希表。集合中的各项总是按键值排序。</p><p>下表为SortedList类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>Capacity</code></td><td>获取或设置SortedList可包含的元素个数</td><td><code>Count</code></td><td>获取SortedList中实际包含的元素个数</td></tr><tr><td><code>IsFixedSize</code></td><td>获取一个值，表示SortedList是否具有固定大小</td><td><code>IsReadOnly</code></td><td>获取一个值，表示SortedList是否只读</td></tr><tr><td><code>Item</code></td><td>获取或设置SortedList中指定键相关的值</td><td><code>Keys</code></td><td>获取SortedList中的键</td></tr><tr><td><code>Values</code></td><td>获取SortedList中的值</td><td></td><td></td></tr></tbody></table><p>下表为ArrayList类的常用方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>public virtual int Add(object key, object Value);</code></td><td>向SortedList添加一个带有指定键和值的元素</td><td><code>public virtual bool ContainsKey(object key);</code></td><td>判断SortedList是否存在指定的键</td></tr><tr><td><code>public virtual void Clear();</code></td><td>在SortedList中移除所有元素</td><td><code>public virtual bool ContainsValue(object value);</code></td><td>判断SortedList是否存在指定的值</td></tr><tr><td><code>public virtual object GetByIndex(int index);</code></td><td>获取SortedList的指定索引处的值</td><td><code>public virtual object GetKey(int index);</code></td><td>获取SortedList的指定索引处的键</td></tr><tr><td><code>public virtual IList GetKeyList();</code></td><td>获取SortedList中的键</td><td><code>public virtual IList GetValueList();</code></td><td>获取SortedList中的值</td></tr><tr><td><code>public virtual void Remove(object key);</code></td><td>从SortedList中移除带有指定的键的元素</td><td><code>public virtual void RemoveAt(int index);</code></td><td>移除SortedList中指定索引处的元素</td></tr><tr><td><code>public virtual int IndexOfKey(object key);</code></td><td>返回SortedList中的指定键的索引</td><td><code>public virtual int IndexOfValue(object key);</code></td><td>返回SortedList中的指定值第一次出现的索引</td></tr><tr><td><code>public virtual void TrimToSize();</code></td><td>设置容量为SortedList中元素的实际个数</td><td></td><td></td></tr></tbody></table><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">SortedListTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            SortedList sortedL = <span class="keyword">new</span> SortedList();</span><br><span class="line">            sortedL.Add(<span class="string">"001"</span>, <span class="string">"AAA"</span>);</span><br><span class="line">            sortedL.Add(<span class="string">"002"</span>, <span class="string">"BBB"</span>);</span><br><span class="line">            sortedL.Add(<span class="string">"003"</span>, <span class="string">"CCC"</span>);</span><br><span class="line">            sortedL.Add(<span class="string">"004"</span>, <span class="string">"DDD"</span>);</span><br><span class="line">            sortedL.Add(<span class="string">"005"</span>, <span class="string">"EEE"</span>);</span><br><span class="line">            <span class="keyword">if</span> (sortedL.ContainsValue(<span class="string">"FFF"</span>))</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"The 'FFF' is already in the table"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                sortedL.Add(<span class="string">"006"</span>, <span class="string">"FFF"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 获取键的集合</span></span><br><span class="line">            ICollection keys = sortedL.Keys;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">string</span> k <span class="keyword">in</span> keys)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(k + <span class="string">": "</span> + sortedL[k]);</span><br><span class="line">            }</span><br><span class="line">			<span class="comment">// 001: AAA</span></span><br><span class="line">            <span class="comment">// 002: BBB</span></span><br><span class="line">			<span class="comment">// 003: CCC</span></span><br><span class="line">			<span class="comment">// 004: DDD</span></span><br><span class="line">			<span class="comment">// 005: EEE</span></span><br><span class="line">            <span class="comment">// 006: FFF</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-4-堆栈Stack">7.4 堆栈Stack</h3><p><strong>堆栈Stack代表了一个后进先出的对象集合</strong>，当需要对各项进行后进先出的访问时，则使用堆栈。当在列表中添加一项，称为推入元素，当从列表中移除一项时，称为弹出元素。</p><p>下表为Stack类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>Count</code></td><td>获取Stack中包含的元素个数</td></tr></tbody></table><p>下表为Stack类的常用方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>public virtual void Clear();</code></td><td>从Stack中移除所有的元素</td><td><code>public virtual bool Contains(object obj);</code></td><td>判断某个元素是否在Stack中</td></tr><tr><td><code>public virtual object Peek();</code></td><td>返回在Stack的顶部的对象，但不移除它</td><td><code>public virtual object Pop();</code></td><td>移除并返回Stack的顶部的对象</td></tr><tr><td><code>public virtual void Push(object obj);</code></td><td>向Stack的顶部添加一个对象</td><td><code>public virtual object[] ToArray();</code></td><td>复制Stack到一个新的数组中</td></tr></tbody></table><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">StackTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            Stack st = <span class="keyword">new</span> Stack();</span><br><span class="line">            st.Push(<span class="string">'A'</span>);</span><br><span class="line">            st.Push(<span class="string">'B'</span>);</span><br><span class="line">            st.Push(<span class="string">'C'</span>);</span><br><span class="line">            st.Push(<span class="string">'D'</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> st)</span><br><span class="line">            {</span><br><span class="line">            	Console.Write(c + <span class="string">" "</span>); </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// D C B A</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            st.Push(<span class="string">'E'</span>);</span><br><span class="line">            st.Push(<span class="string">'F'</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"The next popable value in stack: {0}"</span>, st.Peek());</span><br><span class="line">            <span class="comment">// The next popable value in stack: F</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> st)</span><br><span class="line">            {</span><br><span class="line">            	Console.Write(c + <span class="string">" "</span>); </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// F E D C B A</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            st.Pop();</span><br><span class="line">            st.Pop();</span><br><span class="line">            st.Pop();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> st)</span><br><span class="line">            {</span><br><span class="line">            	Console.Write(c + <span class="string">" "</span>); </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// C B A</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-5-队列Queue">7.5 队列Queue</h3><p><strong>队列Queue代表了一个先进先出的对象集合</strong>，当需要对各项进行先进先出的访问时，则使用队列。当在列表中添加一项，称为入队，当从列表中移除一项，称为出队。</p><p>下表为Queue类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>Count</code></td><td>获取Queue中包含的元素个数</td></tr></tbody></table><p>下表为Stack类的常用方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>public virtual void Clear();</code></td><td>从Queue中移除所有的元素</td><td><code>public virtual bool Contains(object obj);</code></td><td>判断某个元素是否在Queue中</td></tr><tr><td><code>public virtual object Dequeue();</code></td><td>移除并返回在Queue的开头的对象</td><td><code>public virtual void Enqueue(object obj);</code></td><td>向Queue的末尾添加一个对象</td></tr><tr><td><code>public virtual object[] ToArray();</code></td><td>复制Queue到一个新的数组中</td><td><code>public virtual void TrimToSize();</code></td><td>设置容量为Queue中元素的实际个数</td></tr></tbody></table><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">QueueTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            Queue q = <span class="keyword">new</span> Queue();</span><br><span class="line">            q.Enqueue(<span class="string">'A'</span>);</span><br><span class="line">            q.Enqueue(<span class="string">'B'</span>);</span><br><span class="line">            q.Enqueue(<span class="string">'C'</span>);</span><br><span class="line">            q.Enqueue(<span class="string">'D'</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> q)</span><br><span class="line">            {</span><br><span class="line">            	Console.Write(c + <span class="string">" "</span>); </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// A B C D</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            q.Enqueue(<span class="string">'E'</span>);</span><br><span class="line">            q.Enqueue(<span class="string">'F'</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> q)</span><br><span class="line">            {</span><br><span class="line">            	Console.Write(c + <span class="string">" "</span>); </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// A B C D E F</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            q.Dequeue();</span><br><span class="line">            q.Dequeue();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> q)</span><br><span class="line">            {</span><br><span class="line">            	Console.Write(c + <span class="string">" "</span>); </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// C D E F</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-6-点阵列BitArray">7.6 点阵列BitArray</h3><p><strong>点阵列BitArray类管理一个紧凑型的位值数组，它是由布尔值来表示，其中true表示位是开启的，false表示位是关闭的</strong>，当你需要存储位，但是事先不知道位数时，则使用点阵列。可以使用整型索引从点阵列集合中访问各项，索引从零开始。</p><p>下表为BitArray类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>Count</code></td><td>获取BitArray中包含的元素个数</td></tr><tr><td><code>IsReadyOnly</code></td><td>获取一个值，表示BitArray是否只读</td></tr><tr><td><code>Item</code></td><td>获取或设置BitArray中指定位置的位的值</td></tr><tr><td><code>Length</code></td><td>获取或设置BitArray中的元素个数</td></tr></tbody></table><p>下表为BitArray类的常用方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>public BitArray And(BitArray value);</code></td><td>对当前的BitArray中的元素和指定的BitArray中的相应元素执行按位与操作</td><td><code>public bool Get(int index);</code></td><td>获取BitArray中指定位置的位的值</td></tr><tr><td><code>public BitArray Not();</code></td><td>把当前BitArray中的位值反转，以便设置为true的元素为false，设置为false的元素为true</td><td><code>public BitArray Or(BitArray value);</code></td><td>对当前的BitArray中的元素和指定的BitArray中的相应元素执行按位或操作</td></tr><tr><td><code>public void Set(int index, bool value);</code></td><td>把BitArray中指定位置的位设置为指定的值</td><td><code>public void SetAll(bool value);</code></td><td>把BitArray中所有位设置为指定的值</td></tr><tr><td><code>public BitArray Xor(BitArray value);</code></td><td>对当前的BitArray中的元素和指定的BitArray中的相应元素执行按位异或操作</td><td></td><td></td></tr></tbody></table><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">BitArrayTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            BitArray ba1 = <span class="keyword">new</span> BitArray(<span class="number">8</span>);</span><br><span class="line">            BitArray ba2 = <span class="keyword">new</span> BitArray(<span class="number">8</span>);</span><br><span class="line">            <span class="built_in">byte</span>[] a = {<span class="number">60</span>};</span><br><span class="line">            <span class="built_in">byte</span>[] b = {<span class="number">13</span>};</span><br><span class="line">            ba1 = <span class="keyword">new</span> BitArray(a);</span><br><span class="line">            ba2 = <span class="keyword">new</span> BitArray(b);</span><br><span class="line">            Console.WriteLine(<span class="string">"BitArray ba1: 60"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ba1.Count; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.Write(<span class="string">"{0, -6}"</span>, ba1[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// False False True True True True False False</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(<span class="string">"BitArray ba2: 13"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ba2.Count; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.Write(<span class="string">"{0, -6}"</span>, ba2[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// True False True True False False False False</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line"></span><br><span class="line">            BitArray ba3 = <span class="keyword">new</span> BitArray(<span class="number">8</span>);</span><br><span class="line">            ba3 = ba1.And(ba2);</span><br><span class="line">            Console.WriteLine(<span class="string">"BitArray ba3 After And Operation: 12"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ba3.Count; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.Write(<span class="string">"{0, -6}"</span>, ba3[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// False False True True False False False False</span></span><br><span class="line">            Console.WriteLine();    </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="8-泛型">8. 泛型</h2><p>**泛型Generic通过数据类型的代替参数编写类或方法，允许编写一个可以与任何类型一起工作的方法或类。**当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理指定的数据类型。</p><p>示例如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericArray</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> T[] array;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyGenericArray</span>(<span class="params"><span class="built_in">int</span> size</span>)</span></span><br><span class="line">        {</span><br><span class="line">            array = <span class="keyword">new</span> T[size + <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">GetItem</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> array[index];</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetItem</span>(<span class="params"><span class="built_in">int</span> index, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        {</span><br><span class="line">            array[index] = <span class="keyword">value</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GenericTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 声明一个整型数组</span></span><br><span class="line">            MyGenericArray&lt;<span class="built_in">int</span>&gt; intArray = <span class="keyword">new</span> MyGenericArray&lt;<span class="built_in">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">            <span class="comment">// 设置值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                intArray.SetItem(i, i*i);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 获取值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.Write(intArray.GetItem(i) + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 0 1 4 9 16</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            <span class="comment">// 声明一个字符数组</span></span><br><span class="line">            MyGenericArray&lt;<span class="built_in">char</span>&gt; charArray = <span class="keyword">new</span> MyGenericArray&lt;<span class="built_in">char</span>&gt;(<span class="number">5</span>);</span><br><span class="line">            <span class="comment">// 设置值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                charArray.SetItem(i, (<span class="built_in">char</span>)(i+<span class="number">97</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 获取值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.Write(charArray.GetItem(i) + <span class="string">" "</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// a b c d e</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="8-1-特性">8.1 特性</h3><p>使用泛型是一种增强程序功能的技术，具体表现在以下几个方面：</p><ul><li>有助于最大限度地重用代码、保护类型的安全以及提高性能</li><li>可以创建泛型集合类，使用泛型集合类来代替System.Collections中的集合类</li><li>可以创建自己的泛型接口、泛型类、泛型方法、泛型事件、泛型委托。</li><li>对泛型类进行约束以访问特定数据类型的方法</li><li>关于泛型数据类型中使用的类型的信息可运行时通过使用反射获取</li></ul><h3 id="8-2-泛型方法">8.2 泛型方法</h3><p>可以通过类型参数声明泛型方法。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GenericTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T l, <span class="keyword">ref</span> T r</span>)</span></span><br><span class="line">        {</span><br><span class="line">            T temp;</span><br><span class="line">            temp = l;</span><br><span class="line">            l = r;</span><br><span class="line">            r = temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">int</span> a, b;</span><br><span class="line">            <span class="built_in">char</span> c, d;</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">            b = <span class="number">20</span>;</span><br><span class="line">            c = <span class="string">'M'</span>;</span><br><span class="line">            d = <span class="string">'N'</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"a = {0}, b = {1}, c = {2}, d = {3}"</span>, a, b, c, d);</span><br><span class="line">            <span class="comment">// a = 10, b = 20, c = M, d = N</span></span><br><span class="line">            Swap&lt;<span class="built_in">int</span>&gt;(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line">            Swap&lt;Char&gt;(<span class="keyword">ref</span> c, <span class="keyword">ref</span> d);</span><br><span class="line">            Console.WriteLine(<span class="string">"a = {0}, b = {1}, c = {2}, d = {3}"</span>, a, b, c, d);</span><br><span class="line">            <span class="comment">// a = 20, b = 10, c = N, d = M</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="8-3-泛型委托">8.3 泛型委托</h3><p>可以通过类型参数定义泛型委托，如<code>delegate T NumberChange&lt;T&gt;(T n);</code></p><p>示例如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">NumberChanger</span>&lt;<span class="title">T</span>&gt;(<span class="params">T n</span>)</span>;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GenericTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">        {</span><br><span class="line">            num += p;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line">        {</span><br><span class="line">            num *= q;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetNum</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            NumberChanger&lt;<span class="built_in">int</span>&gt; nc1 = <span class="keyword">new</span> NumberChanger&lt;<span class="built_in">int</span>&gt;(AddNum);</span><br><span class="line">            NumberChanger&lt;<span class="built_in">int</span>&gt; nc2 = <span class="keyword">new</span> NumberChanger&lt;<span class="built_in">int</span>&gt;(MultNum);</span><br><span class="line">            nc1(<span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"num = {0}"</span>, GetNum());  <span class="comment">// num = 15</span></span><br><span class="line">            nc2(<span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"num = {0}"</span>, GetNum());  <span class="comment">// num = 75</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="8-4-泛型约束">8.4 泛型约束</h3><p>在声明泛型方法或泛型类时，可以给泛型加上一定的约束来满足特定的一些条件</p><p>如：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Helper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">new</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>泛型限定条件：</p><ul><li>T : 结构 （类型参数必须是值类型，可以指定出Nullable以外的任何值类型）</li><li>T : 类 （类型参数必须是引用类型，包括任何类、接口、委托或数组类型）</li><li>T : new() （类型参数必须具有无参数的公共构造函数，当与其他约束一起使用new()约束必须最后指定）</li><li>T : &lt;基类名&gt; （类型参数必须是指定的基类或派生自指定的基类）</li><li>T : &lt;接口名称&gt; （类型参数必须是指定的接口或实现指定的接口，可以指定多个接口约束。约束接口也可以是泛型的。</li></ul><h2 id="9-匿名方法">9. 匿名方法</h2><p><strong>匿名方法Anonymous methods提供了一种传递代码块作为委托参数的技术，匿名方法是没有名称只有主体的方法。在匿名方法中不需要指定返回类型，它是从方法主体内的return语句推断的。</strong></p><h3 id="9-1-匿名方法的语法">9.1 匿名方法的语法</h3><p>匿名方法是通过使用delegate关键字创建的委托实例来声明的。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br><span class="line"></span><br><span class="line">NumberChanger nc = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(<span class="string">"Anonymous methods: {0}"</span>, x);  <span class="comment">// 匿名方法的主体</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>委托可以通过匿名函数调用，也可以通过普通有名称的函数调用，只需要向委托对象中传递相应的方法参数即可。注：匿名函数主体后面要以<code>;</code>结尾。</p><p>示例如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">AnonymousTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 命名函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">        {</span><br><span class="line">            num += p;</span><br><span class="line">            Console.WriteLine(<span class="string">"命名函数：{0}"</span>, num);</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line">        {</span><br><span class="line">            num *= q;</span><br><span class="line">            Console.WriteLine(<span class="string">"命名函数：{0}"</span>, num);</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            NumberChanger nc = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">            {</span><br><span class="line">            	Console.WriteLine(<span class="string">"匿名函数：{0}"</span>, x);  </span><br><span class="line">            };</span><br><span class="line">            <span class="comment">// 使用匿名函数调用委托</span></span><br><span class="line">            nc(<span class="number">10</span>);  <span class="comment">// 匿名函数：10</span></span><br><span class="line">            <span class="comment">// 使用命名函数实例化委托</span></span><br><span class="line">            nc = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">            nc(<span class="number">5</span>);  <span class="comment">// 命名函数：15</span></span><br><span class="line">            nc = <span class="keyword">new</span> NumberChanger(MultNum);</span><br><span class="line">            nc(<span class="number">5</span>);  <span class="comment">// 命名函数：75</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="10-不安全代码">10. 不安全代码</h2><p>为了保持类型的安全性，默认情况下C#是不支持指针的，但是如果使用<code>unsafe</code>关键字来修饰类或类中的成员，则会被视为不安全代码。C#允许不安全代码中使用指针变量。</p><p>在公共语言运行中，不安全代码是指无法验证的代码，需要程序员来保证代码的安全性，不安全代码并不意味着一定是危险的。</p><h3 id="10-1-指针变量">10.1 指针变量</h3><p>指针也是变量，但是它的值是另一个变量的内存地址，在使用指针前需要先声明指针。</p><table><thead><tr><th>示例</th><th>说明</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>int* p</code></td><td>p是指向整数的指针</td><td><code>double* p</code></td><td>p是指向双精度数的指针</td></tr><tr><td><code>float* p</code></td><td>p是指向浮点数的指针</td><td><code>int** p</code></td><td>p是指向整数的指针的指针</td></tr><tr><td><code>int*[] p</code></td><td>p是指向整数的指针的一维数组</td><td><code>char* p</code></td><td>p是指向字符的指针</td></tr><tr><td><code>void* p</code></td><td>p是指向未知类型的指针</td><td></td><td></td></tr></tbody></table><p>与声明变量相同，我们同样可以在一行代码中同时声明多个指针，如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>* p1, p2, p3;  <span class="comment">// 同时定义p1、p2、p3三个整数指针</span></span><br></pre></td></tr></tbody></table></figure><p>注意：指针不能从对象中继承，并且装箱和拆箱也不支持指针，但是不同的指针类型以及指针与整型之间可以进行转换。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PointerTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">double</span> f = <span class="number">3.1415</span>;</span><br><span class="line">            <span class="built_in">double</span>* p = &amp;f;</span><br><span class="line">            Console.WriteLine(<span class="string">"数据的内容是：{0}"</span>, f);  <span class="comment">// 字符串的内容是: 3.1415</span></span><br><span class="line">            Console.WriteLine(<span class="string">"数据在内存中的地址是：{0}"</span>, (<span class="built_in">int</span>)p);  <span class="comment">// 字符串在内存中的地址是: 12569862</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：在编译上述代码时需要在编译命令中添加<code>-unsafe</code>，例如<code>csc -unsafe pointerTest.cs</code></p><h3 id="10-2-使用指针检索数据的值">10.2 使用指针检索数据的值</h3><p>可以使用<code>ToString()</code>来获取指针变量所指向的数据的值，如下所示：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PointerTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">unsafe</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">int</span> <span class="keyword">var</span> = <span class="number">123456</span>;</span><br><span class="line">            <span class="built_in">int</span>* p = &amp;<span class="keyword">var</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"变量var的值为：{0}"</span>, <span class="keyword">var</span>);  <span class="comment">// 变量var的值为: 123456</span></span><br><span class="line">            Console.WriteLine(<span class="string">"指针p指向的值为：{0}"</span>, p-&gt;ToString());  <span class="comment">// 指针p指向的值为: 123456</span></span><br><span class="line">            Console.WriteLine(<span class="string">"指针p的值为：{0}"</span>, (<span class="built_in">int</span>)p);  <span class="comment">// 指针p的值为: 15332624</span></span><br><span class="line">           </span><br><span class="line">        }</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="10-3-将指针作为参数传递给函数">10.3 将指针作为参数传递给函数</h3><p>可以将指针变量作为参数传递给函数，如下所示：</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PointerTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">int</span>* p, <span class="built_in">int</span>* q</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">int</span> temp = *p;</span><br><span class="line">            *p = *q;</span><br><span class="line">            *q = temp;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            PointerTest p = <span class="keyword">new</span> PointerTest();</span><br><span class="line">            <span class="built_in">int</span> var1 = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">int</span> var2 = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">int</span>* x = &amp;var1;</span><br><span class="line">            <span class="built_in">int</span>* y = &amp;var2;</span><br><span class="line">            Console.WriteLine(<span class="string">"调用Swap函数前：var1 = {0}, var2 = {1}"</span>, var1, var2);</span><br><span class="line">            <span class="comment">// 调用Swap函数前：var1 = 10, var2 = 20</span></span><br><span class="line">            p.Swap(x, y);</span><br><span class="line">            Console.WriteLine(<span class="string">"调用Swap函数后：var1 = {0}, var2 = {1}"</span>, var1, var2);</span><br><span class="line">            <span class="comment">// 调用Swap函数后：var1 = 20, var2 = 10</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="10-4-使用指针访问数组元素">10.4 使用指针访问数组元素</h3><p>在C#中，数组和指向该数组且与数组名称相同的指针是不同的数据类型，例如<code>int* p</code>和<code>int[] p</code>就是不同的数据类型。可以增加指针p的值，因为它在内存中不是固定的，但数组地址在内存中是固定的，因此不能增加数组p的值，如果需要使用指针变量访问数组数据，则可以使用<code>fixed</code>关键字来固定指针。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">PointerTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">int</span>[] list = {<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>};</span><br><span class="line">            <span class="keyword">fixed</span>(<span class="built_in">int</span> *ptr = list);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"List[{0}]的内存地址为：{1}"</span>, i, (<span class="built_in">int</span>)(ptr + i));</span><br><span class="line">                Console.WriteLine(<span class="string">"List[{0}]的值为：{1}"</span>, i, *(ptr + i));</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// list[0] 的内存地址为：51981272</span></span><br><span class="line">            <span class="comment">// list[0] 的值为：10</span></span><br><span class="line">            <span class="comment">// list[1] 的内存地址为：51981276</span></span><br><span class="line">            <span class="comment">// list[1] 的值为：100</span></span><br><span class="line">            <span class="comment">// list[2] 的内存地址为：51981280</span></span><br><span class="line">            <span class="comment">// list[2] 的值为：200</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="11-正则表达式">11. 正则表达式</h2><p><strong>正则表达式时一种匹配文本输入的模式。</strong>.Net Framework提供了允许这种匹配的正则表达式引擎。模式由一个或多个字符、运算符和结构组成。</p><h3 id="11-1-定义正则表达式">11.1 定义正则表达式</h3><p>用于定义正则表达式的各种类型的字符、运算符和结构有：</p><ul><li>字符转义，正则表达式中的反斜杠<code>\</code>用来表示它后面跟随的字符时特殊字符，具有特殊的含义。如\a、\b、\t等</li><li>字符类，字符类可以与一个字符串中的任何一个字符相匹配。如\w、[character_group]、\p{name}等</li><li>定位符，可以根据字符串出现的具体位置来判断匹配是成功还是失败。如^、$、\A等</li><li>分组结构，描述了正则表达式的子表达式，并捕获输入字符串的子字符串。如（\w)\1、\w+(?=\.)、(?&lt;double&gt;\w)\k&lt;double&gt;等</li><li>限定符，用来指定在字符串中必须存在某个元素才能匹配成功。如*、+、？等</li><li>反向引用构造，允许先前匹配的子表达式随后在相同的正则表达式中进行标志。如\number、\k&lt;name&gt;</li><li>备用构造，用于修改正则表达式以启用either/or匹配。如|、(?(expresion) yes | no)、(?(name)yes | no)</li><li>替换，替换模式中使用的正则表达式，如$number、${name}、$&amp;等</li><li>杂项构造，如(?#注释)、#[行尾]、(?imnsx-imnsx)</li></ul><h3 id="11-2-Regex类">11.2 Regex类</h3><p>Regex类用于使用一个正则表达式，下表列出来Regex类中一些常用的方法：</p><table><thead><tr><th>方法</th><th>描述</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>public bool IsMatch( string input )</code></td><td>指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项</td><td><code>public bool IsMatch( string input, int startat )</code></td><td>指示 Regex 构造函数中指定的正则表达式是否在指定的输入字符串中找到匹配项，从字符串中指定的位置开始查找</td></tr><tr><td><code>public static bool IsMatch( string input, string pattern )</code></td><td>指示指定的正则表达式是否在指定的输入字符串中找到匹配项</td><td><code>public MatchCollection Matches( string input )</code></td><td>在指定的输入字符串中搜索正则表达式的所有匹配项</td></tr><tr><td><code>public string Replace( string input, string replacement )</code></td><td>在指定的输入字符串中，把所有匹配正则表达式模式的所有匹配的字符串替换为指定的替换字符串</td><td><code>public string[] Split( string input )</code></td><td>把输入字符串分割为子字符串数组，根据在 Regex 构造函数中指定的正则表达式模式定义的位置进行分割</td></tr></tbody></table><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">RegexTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMatch</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> expr</span>)</span></span><br><span class="line">        {</span><br><span class="line">            MatchCollection mc = Regex.Matches(text, expr);</span><br><span class="line">            <span class="keyword">foreach</span> (Match m <span class="keyword">in</span> mc)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(m);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">"make and then manage your maze"</span>;</span><br><span class="line">            ShowMatch(str, <span class="string">@"\bm\S*e\b"</span>);</span><br><span class="line">            <span class="comment">// make</span></span><br><span class="line">            <span class="comment">// manage</span></span><br><span class="line">            <span class="comment">// maze</span></span><br><span class="line">            </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="12-多线程">12. 多线程</h2><p><strong>多线程就是多个线程同时工作的过程，可将线程看做程序的执行路径，每个线程定义了一个独特的控制流，用来完成特定的任务。</strong></p><p>多线程可以节省CPU资源，同时提高应用程序的执行效率。</p><h3 id="12-1-线程生命周期">12.1 线程生命周期</h3><p>线程声明周期开始于我们创建<strong>System.Theading.Thread</strong>类对象的时候，当线程被终止或完成执行时生命周期终止。</p><p>下面列出来线程生命周期中的各种状态：</p><ul><li>未启动状态：当线程实例被创建但<code>Start</code>方法未被调用时的状况；</li><li>就绪状态：当线程准备好运行并等待CPU周期时的状况；</li><li>不可运行状态：<ul><li>已经调用Sleep方法</li><li>已经调用Wait方法</li><li>通过I/O操作阻塞</li></ul></li><li>死亡状态：当线程已完成执行或已中止时的状况。</li></ul><h3 id="12-2-主线程">12.2 主线程</h3><p>在多线程中执行的第一个线程称为主线程，C#程序开始执行时，将自动创建主线程，使用Thread类创建的线程称为子线程，可以使用<strong>Thread</strong>类的<code>CurrentThread</code>属性访问线程。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            Thread th = Thread.CurrentThread;</span><br><span class="line">            th.Name = <span class="string">"主线程"</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"这是{0}"</span>, th.Name);  <span class="comment">// 这是主线程</span></span><br><span class="line">            </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="12-3-Thread类的常用属性和方法">12.3 Thread类的常用属性和方法</h3><p>下表为Thread类的常用属性：</p><table><thead><tr><th>属性</th><th>描述</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>CurrentContext</code></td><td>获取线程正在其中执行的当前上下文</td><td><code>CurrentCulture</code></td><td>获取或设置当前线程的区域性</td></tr><tr><td><code>CurrentPrincipal</code></td><td>获取或设置线程的当前负责人</td><td><code>CurrentThread</code></td><td>获取当前正在运行的线程</td></tr><tr><td><code>CurrentUICulture</code></td><td>获取或设置资源管理器使用的当前区域性以便在运行时查找区域特定的资源</td><td><code>ExecutionContext</code></td><td>获取一个ExecutionContext对象，该对象包含有关当前线程的各种上下文信息</td></tr><tr><td><code>IsAlive</code></td><td>获取一个值，该值指示当前线程的执行状态</td><td><code>IsBackground</code></td><td>获取或设置一个值，该值指示某个线程是否为后台线程</td></tr><tr><td><code>IsThreadPoolThread</code></td><td>获取一个值，该值指示线程是否属于托管线程池</td><td><code>ManagedThreadId</code></td><td>获取当前托管线程的唯一标识符</td></tr><tr><td><code>Name</code></td><td>获取或设置线程的名称</td><td><code>Priority</code></td><td>获取或设置一个值，该值指示线程的调度优先级</td></tr><tr><td><code>ThreadState</code></td><td>获取一个值，该值包含当前线程的状态</td><td></td><td></td></tr></tbody></table><p>下表为Thread类的常用方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>public void Abort()</code></td><td>在调用此方法的线程上引发ThreadAbortException，以开始终止此线程的过程。调用此方法通常会终止线程</td><td><code>public static LocalDataStoreSlot AllocateDataSlot()</code></td><td>在所有线程上分配未命名的数据槽</td></tr><tr><td><code>public static LocalDataStoreSlot AllocateNamedDataSlot(string name)</code></td><td>在所有线程上分配已命名的数据槽</td><td><code>public static void BeginCriticalRegion()</code></td><td>通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常的影响可能会危害应用程序域中的其他任务</td></tr><tr><td><code>public static void BeginThreadAffinity()</code></td><td>通知主机托管代码将要执行依赖于当前物理操作系统线程的标识的指令</td><td><code>public static void EndCriticalRegion()</code></td><td>通知主机执行将要进入一个代码区域，在该代码区域内线程中止或未经处理的异常仅影响当前任务。</td></tr><tr><td><code>public static void EndThreadAffinity()</code></td><td>通知主机托管代码已执行完依赖于当前物理操作系统线程的标识的指令</td><td><code>public static void FreeNamedDataSlot(string name)</code></td><td>为进程中的所有线程消除名称与槽之间的关联</td></tr><tr><td><code>public static Object GetData(LocalDataStoreSlot slot)</code></td><td>在当前线程的当前域中从当前线程上指定的槽中检索值</td><td><code>public static AppDomain GetDomain()</code></td><td>返回当前线程正在其中运行的当前域</td></tr><tr><td><code>public static AppDomain GetDomainID()</code></td><td>返回唯一的应用程序域标识符</td><td><code>public static LocalDataStoreSlot GetNamedDataSlot(string name)</code></td><td>查找已命名的数据槽</td></tr><tr><td><code>public void Interrupt()</code></td><td>中断处于WaitSleep.Join线程状态的线程</td><td><code>public void Join()</code></td><td>在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻塞调用线程，直到某个线程终止为止</td></tr><tr><td><code>public static void MemoryBarrier()</code></td><td>按如下方式同步内存存取：执行当前线程的处理器在对指令重新排序时，不能采用先执行 MemoryBarrier 调用之后的内存存取，再执行 MemoryBarrier 调用之前的内存存取的方式</td><td><code>public static void ResetAbort()</code></td><td>取消为当前线程请求的Abort</td></tr><tr><td><code>public static void SetData(LocalDataStoreSlot slot, Object data)</code></td><td>在当前正在运行的线程上为此线程的当前域在指定槽中设置数据</td><td><code>public void Start()</code></td><td>开始一个线程</td></tr><tr><td><code>public static void Sleep(int millisecondsTimeout)</code></td><td>让线程暂停一段时间</td><td><code>public static void SpinWait(int iterations)</code></td><td>导致线程等待由 iterations 参数定义的时间量</td></tr><tr><td><code>public static byte VolatileRead(ref byte address)</code><br><code>public static double VolatileRead(ref double address)</code><br><code>public static int VolatileRead(ref int address)</code><br><code>public static Object VolatileRead(ref Object address)</code></td><td>读取字段值。无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值</td><td><code>public static void VolatileWrite(ref byte address, byte value)</code><br><code>public static void VolatileWrite(ref double address, double value)</code><br><code>public static void VolatileWrite(ref int address, int value)</code><br><code>public static void VolatileWrite(ref Object address, Object value)</code></td><td>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见</td></tr><tr><td><code>public static bool Yield()</code></td><td>导致调用线程执行准备好在当前处理器上运行的另一个线程。由操作系统选择要执行的线程</td><td></td><td></td></tr></tbody></table><h3 id="12-4-创建线程">12.4 创建线程</h3><p>线程是通过扩展<strong>Thread</strong>类创建的，扩展的<strong>Thread</strong>类调用<code>Start()</code>方法来开始子线程的执行。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallToChildThread</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">"Child thread starts"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            ThreadStart childref = <span class="keyword">new</span> ThreadStart(CallToChildThread);</span><br><span class="line">            Thread childThread = <span class="keyword">new</span> Thread(childref);</span><br><span class="line">            childThread.Start();  <span class="comment">// Child thread starts</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="12-5-管理线程">12.5 管理线程</h3><p><strong>Thread</strong>类提供了各种管理线程的方法，下面演示了<code>Sleep()</code>方法的使用，用于在一个特定的时间暂停线程。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallToChildThread</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">"Child thread starts"</span>);</span><br><span class="line">            <span class="built_in">int</span> sleepTime = <span class="number">5000</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"Child thread paused for {0} seconds"</span>, sleepTime / <span class="number">1000</span>);</span><br><span class="line">            Thread.Sleep(sleepTime);</span><br><span class="line">            Console.WriteLine(<span class="string">"Child thread resumes"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            ThreadStart childref = <span class="keyword">new</span> ThreadStart(CallToChildThread);</span><br><span class="line">            Thread childThread = <span class="keyword">new</span> Thread(childref);</span><br><span class="line">            childThread.Start();</span><br><span class="line">            <span class="comment">// Child thread starts</span></span><br><span class="line">            <span class="comment">// Child thread pasued for 5 seconds</span></span><br><span class="line">            <span class="comment">// Child thread resumes</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="12-6-销毁线程">12.6 销毁线程</h3><p><code>Abort()</code>方法用于销毁进行，通过抛出<code>ThreadAbortException</code>在运行时中止线程。这个异常不能被捕获，如果有<strong>finally</strong>块，控制会被送至<strong>finally</strong>块。</p><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Application</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadTest</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallToChildThread</span>(<span class="params"></span>)</span></span><br><span class="line">        {</span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"Child thread starts"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> counter = <span class="number">0</span>; counter &lt;= <span class="number">10</span>; counter++)</span><br><span class="line">                {</span><br><span class="line">                    Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                    Console.WriteLine(counter);</span><br><span class="line">                }</span><br><span class="line">                Console.WriteLine(<span class="string">"Child thread resumes"</span>);</span><br><span class="line">            }</span><br><span class="line">            catch (ThreadAbortException e)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"Thread Abort Exception"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"Couldn't catch the Thread Exception"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        {</span><br><span class="line">            ThreadStart childref = <span class="keyword">new</span> ThreadStart(CallToChildThread);</span><br><span class="line">            Thread childThread = <span class="keyword">new</span> Thread(childref);</span><br><span class="line">            childThread.Start();</span><br><span class="line">            Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">            childThread.Abort();</span><br><span class="line">            <span class="comment">// Child thread starts</span></span><br><span class="line">            <span class="comment">// 0</span></span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="comment">// Thread Abort Exception</span></span><br><span class="line">            <span class="comment">// Couldn't catch the Thread Exception</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="参考文章-2">参考文章</h2><p>本文是笔者通过下列网站教程学习C#语言进阶的记录，有部分修改和补充，转载请注明出处，并附带下面链接。</p><p>1.<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-tutorial.html">【菜鸟教程C#教程】</a></p><p>2.<a target="_blank" rel="noopener" href="http://c.biancheng.net/csharp/">【C语言中文网C#教程】</a></p><p>3.<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/">【微软C#官方文档】</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://xiongbinzou.github.io">小邹同学</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://xiongbinzou.github.io/posts/16133.html">https://xiongbinzou.github.io/posts/16133.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xiongbinzou.github.io" target="_blank">小邹同学</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/Unity%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">Unity开发基础</a><a class="post-meta__tags" href="/tags/C-%E8%BF%9B%E9%98%B6/">C#进阶</a></div><div class="post_share"><div class="social-share" data-image="/pics/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/pics/reward/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/pics/reward/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/pics/reward/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/pics/reward/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/13057.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Git常用命令记录</div></div></a></div><div class="next-post pull-right"><a href="/posts/6569.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C#语言基础学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6569.html" title="C#语言基础学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-10</div><div class="title">C#语言基础学习笔记</div></div></a></div><div><a href="/posts/5067.html" title="Lua语言学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-04</div><div class="title">Lua语言学习笔记</div></div></a></div><div><a href="/posts/38460.html" title="Docker入门教程学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">Docker入门教程学习笔记</div></div></a></div><div><a href="/posts/47611.html" title="Docker进阶教程学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="title">Docker进阶教程学习笔记</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%89%B9%E6%80%A7"><span class="toc-text">1. 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-text">1.1 预定义特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-text">1.2 自定义特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84"><span class="toc-text">2. 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8F%8D%E5%B0%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2.1 反射优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8F%8D%E5%B0%84%E7%94%A8%E9%80%94"><span class="toc-text">2.2 反射用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9F%A5%E7%9C%8B%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">2.3 查看元数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B1%9E%E6%80%A7"><span class="toc-text">3. 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-get-set%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-text">3.1 get&#x2F;set访问器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8A%BD%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">3.2 抽象属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-text">4. 索引器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%B4%A2%E5%BC%95%E5%99%A8%E5%AE%9A%E4%B9%89"><span class="toc-text">4.1 索引器定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%B4%A2%E5%BC%95%E5%99%A8%E7%94%A8%E9%80%94"><span class="toc-text">4.2 索引器用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%87%8D%E8%BD%BD%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-text">4.3 重载索引器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A7%94%E6%89%98"><span class="toc-text">5. 委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%A3%B0%E6%98%8E%E5%A7%94%E6%89%98"><span class="toc-text">5.1 声明委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A7%94%E6%89%98"><span class="toc-text">5.2 实例化委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A7%94%E6%89%98%E5%A4%9A%E6%92%AD"><span class="toc-text">5.3 委托多播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8B%E4%BB%B6"><span class="toc-text">6. 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%A3%B0%E6%98%8E%E4%BA%8B%E4%BB%B6"><span class="toc-text">6.1 声明事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6"><span class="toc-text">6.2 使用事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%9B%86%E5%90%88"><span class="toc-text">7. 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84ArrayList"><span class="toc-text">7.1 动态数组ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%93%88%E5%B8%8C%E8%A1%A8Hashtable"><span class="toc-text">7.2 哈希表Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8SortedList"><span class="toc-text">7.3 排序列表SortedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%A0%86%E6%A0%88Stack"><span class="toc-text">7.4 堆栈Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E9%98%9F%E5%88%97Queue"><span class="toc-text">7.5 队列Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E7%82%B9%E9%98%B5%E5%88%97BitArray"><span class="toc-text">7.6 点阵列BitArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%B3%9B%E5%9E%8B"><span class="toc-text">8. 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E7%89%B9%E6%80%A7"><span class="toc-text">8.1 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">8.2 泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98"><span class="toc-text">8.3 泛型委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">8.4 泛型约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-text">9. 匿名方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">9.1 匿名方法的语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81"><span class="toc-text">10. 不安全代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-text">10.1 指针变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E5%80%BC"><span class="toc-text">10.2 使用指针检索数据的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%B0%86%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%87%BD%E6%95%B0"><span class="toc-text">10.3 将指针作为参数传递给函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">10.4 使用指针访问数组元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">11. 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">11.1 定义正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-Regex%E7%B1%BB"><span class="toc-text">11.2 Regex类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">12. 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">12.1 线程生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-text">12.2 主线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-Thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">12.3 Thread类的常用属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">12.4 创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="toc-text">12.5 管理线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E9%94%80%E6%AF%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">12.6 销毁线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0-2"><span class="toc-text">参考文章</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image:url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 小邹同学</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你好，欢迎来到<a href="https://xiongbinzou.github.io">小邹同学的Secret Base</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.2},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container:not([display])").forEach((t=>{const e=t.parentNode;"li"===e.nodeName.toLowerCase()?e.parentNode.classList.add("has-jax"):e.classList.add("has-jax")}))},"",!1]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(e.length){window.runMermaid=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,i="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent;mermaid.mermaidAPI.render(r,i,(e=>{d.insertAdjacentHTML("afterend",e)}))}))};const t=()=>{window.loadMermaid?runMermaid():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(runMermaid)};window.pjax?t():document.addEventListener("DOMContentLoaded",t)}})()</script><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"WU7g4I4cNK7LYpz3RJVoz1YV-gzGzoHsz",appKey:"4MHXbgYuTwfEzqQofOeNVquO",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!1},null))}"function"==typeof Valine?n():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(n)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script></div><div class="aplayer no-destroy" data-id="5183531430" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"left",width:150,height:190},mobile:{show:!1},react:{opacity:1}})</script></body></html>